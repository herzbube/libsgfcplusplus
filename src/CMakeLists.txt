include( ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME} )
if ( NOT DEFINED SOURCES )
  message ( FATAL_ERROR "List of source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PRIVATE )
  message ( FATAL_ERROR "List of private header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_PUBLIC )
  message ( FATAL_ERROR "List of public header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED SOURCES_SGFC )
  message ( FATAL_ERROR "List of SGFC source files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()
if ( NOT DEFINED HEADERS_SGFC )
  message ( FATAL_ERROR "List of SGFC header files not defined by ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCES_LIST_FILE_NAME}" )
endif()

# SGFC is written in C, but because libsgfc++ patches the SGFC source code the
# files listed here now contain C++ snippets and therefore must be built with
# the C++ compiler. Here we explicitly configure CMake to override the default
# compiler behaviour, which is to derive the language (C) from the file
# extension (.c).
set_source_files_properties (
  ../sgfc/save.c
  ../sgfc/util.c
  PROPERTIES LANGUAGE CXX
)

# When compiling with MSVC, disable the compiler warning C4996 for SGFC source
# files. The warning complains about sprintf, strcpy and other similar functions
# being unsafe. Although ignoring compiler warnings is not a good practice in
# general, in this case it's practical because replacing the sprintf et al.
# functions with what Microsoft is calling their "secure" counterparts (e.g.
# sprintf_s) is quite controversial.
if ( ${MSVC} )
  set_source_files_properties(
    ${SOURCES_SGFC}
    PROPERTIES
    COMPILE_DEFINITIONS _CRT_SECURE_NO_WARNINGS
  )
endif()

# When compiling with MSVC, disable the compiler warning C4250 for libsgfc++
# source files. The warning complains when a subclass in a multiple-inheritance
# diamond pattern inherits a member from one of its base classes. The compiler
# generates this warning even for completely legal code. Example:
# SgfcBoardSizeProperty inherits the root interface ISgfcProperty twice, once
# via subclassing SgfcProperty and once via subclassing ISgfcBoardSizeProperty.
# In this inheritance diamond the GetPropertyType() method is declared once as
# "pure virtual" in the root interface, and is implemented exactly once in
# SgfcProperty. Despite this perfectly legal and unambiguos class structure the
# compiler generates C4250. There is no other choice but to suppress the warning
# to prevent the build log from being flooded with useless warnings.
if ( ${MSVC} )
  set_source_files_properties(
    ${SOURCES}
    PROPERTIES
    COMPILE_OPTIONS /wd4250
  )
endif()

# An Xcode project that is generated by CMake doesn't build the shared or static
# library targets that we define further down, if the library targets only
# contains object files from the object library. Whether this is a deficiency in
# Xcode or in CMake's Xcode generator is unknown, but the problem seems to be
# well known, as it is even acknowledged in the CMake docs for object libraries
# [1].
#
#   Some native build systems (such as Xcode) may not like targets that have
#   only object files, so consider adding at least one real source file to
#   any target that references $<TARGET_OBJECTS:objlib>.
#
# Here we follow the suggested workaround and remove one source file from the
# list that will be compiled for the object library, for the only reason that
# we can add it to the shared and static library targets further down. Any
# fill will do, the one we pick here has no special significance.
#
# [1] https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries
set ( SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY SgfcUtility.cpp )
list (
  REMOVE_ITEM
  SOURCES
  ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
)

# The following two targets are "object library" targets: They compile the
# sources but don't aggregate them into an actual shared or static library yet.
# The purpose of this is to avoid compiling the sources twice, once for the
# shared/static library and once for the shared/static library framework.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  add_library (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES_SGFC}
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_SGFC}
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  add_library (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    OBJECT
    ${SOURCES_SGFC}
    ${SOURCES}
    # We list header files here only because we want CMake to add them to an
    # Xcode or Visual Studio project that it generates.
    ${HEADERS_SGFC}
    ${HEADERS_PUBLIC}
    ${HEADERS_PRIVATE}
  )
endif()

# Here we finally build the shared and static libraries. We build them
# from the same set of object files.
if ( ${ENABLE_SHARED_LIBRARY} )
  add_library (
    ${SHARED_LIBRARY_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  add_library (
    ${STATIC_LIBRARY_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
  )
endif()

# For macOS and iOS we also provide a shared library framework and a static
# library framework. They are composed of the exact same stuff as the regular
# libraries.
if ( ${ENABLE_SHARED_FRAMEWORK} )
  add_library (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    SHARED
    $<TARGET_OBJECTS:${SHARED_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # Furtherdown we invoke set_property() to set the targets' PUBLIC_HEADER
    # property. For the shared and static library targets this works fine and
    # causes CMake to copy the header files to their proper destination at
    # installation time. For the framework targets, just setting the PUBLIC_HEADER
    # property alone is not sufficient: We also have to list the public headers
    # here in this add_library() invocation, otherwise CMake does not copy them
    # into the framework bundle at build time. This workaround can be found on
    # the CMake mailing list [1] in a thread dating from 2015.
    # [1] http://cmake.3232098.n2.nabble.com/OS-X-framework-headers-with-capital-letters-td7591087.html
    ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  add_library (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    STATIC
    $<TARGET_OBJECTS:${STATIC_OBJECT_LIBRARY_TARGET_NAME}>
    ${SOURCE_FILE_EXCEPTED_FROM_OBJECT_LIBRARY}
    # For an explanation of this line, see the comment above in the add_library()
    # command for SHARED_FRAMEWORK_TARGET_NAME.
    ${HEADERS_PUBLIC}
  )
endif()

# Generate the export header file.
include ( GenerateExportHeader )
generate_export_header (
  ${EXPORT_HEADER_TARGET_NAME}

  # EXPORT_HEADER_TARGET_NAME is variable, but we need to have a static base
  # name that does not change, so that the source code can use preprocessor
  # macros with stable names.
  BASE_NAME ${EXPORT_HEADER_BASE_NAME}

  # The default header file name looks ugly: sgfcplusplus_export.h
  # Let's define a file name that looks more in line with the rest of the
  # project.
  EXPORT_FILE_NAME ${EXPORT_HEADER_FILE_NAME}
)

# Here we associate the public header files with the library and framework
# targets. This causes CMake to install them automatically, without us having
# to define a special install rule.
# - For frameworks this is necessary because each framework gets its own copy
#   of the header files.
# - For the libraries we would need only one association because when installed
#   both libraries share the same set of header files. We still associate the
#   files with both library targets, to make sure that the header files will be
#   installed even if the user chooses to build and install only one of the
#   libraries. If the user builds and installs both libraries, then the header
#   files will get installed twice.
#
# Note: It's not possible to make the association with all targets at the same
# time with only one single invocation of set_target_properties(). For unknown
# reasons this does not work, it only copies one single header file to be copied
# instead of the the entire set.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_property (
    TARGET ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_property (
    TARGET ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTY PUBLIC_HEADER ${HEADERS_PUBLIC}
  )
endif()

# Set the targets' output names, which in some cases deviate from the target
# name.
if ( ${ENABLE_SHARED_LIBRARY} )
  set_target_properties (
    ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  set_target_properties (
    ${STATIC_LIBRARY_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_LIBRARY_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${SHARED_FRAMEWORK_OUTPUT_NAME}"
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    OUTPUT_NAME "${STATIC_FRAMEWORK_OUTPUT_NAME}"
  )
endif()

# Mark the framework targets as frameworks. Because of this CMake generates
# the framework bundle folder structure on macOS/iOS.
# TODO: Set more properties. Check out this example:
# https://cmake.org/cmake/help/latest/prop_tgt/FRAMEWORK.html
if ( ${ENABLE_SHARED_FRAMEWORK} )
  set_target_properties (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  set_target_properties (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTIES
    FRAMEWORK TRUE
  )
endif()

# Define additional folders where to look for include files.
# Currently we have only one: The folder where the export header file is
# located. See further up where we generate that file with
# generate_export_header().
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_include_directories (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_include_directories (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_include_directories (
    ${SHARED_LIBRARY_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  target_include_directories (
    ${STATIC_LIBRARY_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  target_include_directories (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  target_include_directories (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PUBLIC
    ${EXPORT_HEADER_FILE_FOLDER}
  )
endif()

# Define additional compile options.
# - EXPORT_HEADER_EXPORTS_MACRO_NAME macro: Must be defined for the shared
#   library/framework builds to turn on symbol visibility.
# - EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME macro: Must be defined for the static
#   library/framework builds to turn off symbol visibility.
# - COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS: Tell the compiler that
#   C functions may throw exceptions. See main CMake config file for details.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${AT_LEAST_ONE_STATIC_LIBRARY_IS_ENABLED} )
  target_compile_options (
    ${STATIC_OBJECT_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  target_compile_options (
    ${SHARED_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_STATIC_LIBRARY} )
  target_compile_options (
    ${STATIC_LIBRARY_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_SHARED_FRAMEWORK} )
  target_compile_options (
    ${SHARED_FRAMEWORK_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_EXPORTS_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()
if ( ${ENABLE_STATIC_FRAMEWORK} )
  target_compile_options (
    ${STATIC_FRAMEWORK_TARGET_NAME}
    PUBLIC
    -D${EXPORT_HEADER_STATIC_DEFINE_MACRO_NAME}
    ${COMPILE_OPTION_C_FUNCTIONS_MAY_THROW_EXCEPTIONS}
  )
endif()

# More compile options: Shared libraries need PIC.
if ( ${AT_LEAST_ONE_SHARED_LIBRARY_IS_ENABLED} )
  set_property (
    TARGET ${SHARED_OBJECT_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ${ENABLE_SHARED_LIBRARY} )
  set_property (
    TARGET ${SHARED_LIBRARY_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  set_property (
    TARGET ${STATIC_FRAMEWORK_TARGET_NAME}
    PROPERTY POSITION_INDEPENDENT_CODE 1
  )
endif()

# On some systems CMake automatically populates the LIBRARY and PUBLIC_HEADER
# destinations with values defined by the GNUInstallDirs module (e.g. macOS with
# CMake 3.11 and Xcode, Windows with CMake 3.16 and VisualStudio). On other
# systems CMake does not do it automatically (e.g. Ubuntu 18.04 with CMake 3.12
# and GCC, which corresponds to the Travis build system "bionic"). To satisfy
# all systems we have to populate the destinations manually.
if ( ${ENABLE_SHARED_LIBRARY} )
  install (
    TARGETS
    ${SHARED_LIBRARY_TARGET_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
if ( ENABLE_STATIC_LIBRARY )
  install (
    TARGETS
    ${STATIC_LIBRARY_TARGET_NAME}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
if ( ENABLE_SHARED_FRAMEWORK )
  install (
    TARGETS
    ${SHARED_FRAMEWORK_TARGET_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
if ( ENABLE_STATIC_FRAMEWORK )
  install (
    TARGETS
    ${STATIC_FRAMEWORK_TARGET_NAME}
    FRAMEWORK DESTINATION ${FRAMEWORK_DESTINATION_FOLDER_NAME}
    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
  )
endif()
